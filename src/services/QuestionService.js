// Service to handle questions via Local API (Node.js + SQLite)

const API_URL = '/api/questions';

export const QuestionService = {
    getAll: async () => {
        try {
            const res = await fetch(API_URL);
            if (!res.ok) throw new Error('Failed to fetch questions');
            return await res.json();
        } catch (error) {
            console.error('Error fetching questions:', error);
            return [];
        }
    },

    getStats: async () => {
        try {
            const res = await fetch('/api/stats');
            if (!res.ok) throw new Error('Failed to fetch stats');
            return await res.json();
        } catch (error) {
            console.error('Error fetching stats:', error);
            return [];
        }
    },

    saveAll: async (questions) => {
        try {
            // Ensure format matches API expectation
            const formatted = questions.map(q => ({
                question: q.question,
                tags: q.tags,
                answers: q.answers,
                // id will be generated by backend if missing
            }));

            const res = await fetch(API_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(formatted)
            });

            if (!res.ok) throw new Error('Failed to save questions');

            return await res.json();
        } catch (error) {
            console.error('Error saving questions:', error);
            throw error;
        }
    },

    getQuestionsByTag: async (tag, limit = 10) => {
        try {
            // Use backend filtering and limiting
            const url = new URL(API_URL, window.location.origin);
            if (tag) url.searchParams.append('tag', tag);
            if (limit) url.searchParams.append('limit', limit);

            const res = await fetch(url);
            if (!res.ok) throw new Error('Failed to fetch questions');
            return await res.json();
        } catch (error) {
            console.error('Error fetching by tag:', error);
            // Fallback to getting all if filter fails, though backend should handle it
            const all = await QuestionService.getAll();
            return all.slice(0, limit);
        }
    },

    recordAttempt: async (questionId, isCorrect) => {
        try {
            await fetch('/api/attempts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ question_id: questionId, is_correct: isCorrect })
            });
        } catch (e) {
            console.error('Failed to record stats', e);
        }
    },

    deleteQuestion: async (id) => {
        try {
            const res = await fetch(`${API_URL}/${id}`, {
                method: 'DELETE'
            });
            if (!res.ok) throw new Error('Failed to delete question');
            return true;
        } catch (error) {
            console.error('Error deleting question:', error);
            throw error;
        }
    },

    deleteAll: async () => {
        try {
            const res = await fetch(API_URL, {
                method: 'DELETE'
            });
            if (!res.ok) throw new Error('Failed to delete all questions');
            return true;
        } catch (error) {
            console.error('Error deleting all questions:', error);
            throw error;
        }
    },

    resetStats: async () => {
        try {
            const res = await fetch('/api/reset', {
                method: 'POST'
            });
            if (!res.ok) throw new Error('Failed to reset stats');
            return true;
        } catch (error) {
            console.error('Error resetting stats:', error);
            throw error;
        }
    },

    updateQuestion: async (id, question) => {
        try {
            const res = await fetch(`${API_URL}/${id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(question)
            });
            if (!res.ok) throw new Error('Failed to update question');
            return true;
        } catch (error) {
            console.error('Error updating question:', error);
            throw error;
        }
    }
};
